---
# Playbook 04: Deploy platform services using Helm
- name: Deploy Harbor, ArgoCD, and Cert-Manager with Helm
  hosts: k3s_master
  become: true
  gather_facts: true
  
  vars:
    kubeconfig_path: /etc/rancher/k3s/k3s.yaml
    # æ³¨æ„: å…¶ä»–é…ç½®å˜é‡å·²ç§»è‡³ group_vars/all.yml
    # å¯ä»¥åœ¨é‚£é‡Œç»Ÿä¸€ä¿®æ”¹ ArgoCD å®‰è£…æ–¹å¼å’Œå…¶ä»–é…ç½®

  tasks:
    # ============================================================
    # å‰ç½®æ£€æŸ¥
    # ============================================================
    - name: Check if Helm is installed
      command: which helm
      register: helm_check
      failed_when: false
      changed_when: false
    
    - name: Fail if Helm is not installed
      fail:
        msg: "Helm is not installed. Please run playbook 03-deploy-platform.yml first."
      when: helm_check.rc != 0
    
    - name: Check K3s cluster status
      command: k3s kubectl get nodes
      register: k3s_status
      changed_when: false
      failed_when: k3s_status.rc != 0
    
    - name: Display cluster status
      debug:
        msg: "K3s cluster is ready with {{ k3s_status.stdout_lines | length - 1 }} nodes"

    # ============================================================
    # éƒ¨ç½² Cert-Manager (æœ€å…ˆéƒ¨ç½²ï¼Œå…¶ä»–æœåŠ¡å¯èƒ½éœ€è¦è¯ä¹¦)
    # ============================================================
    - name: Check if Cert-Manager is already installed
      shell: helm list -n {{ platform_namespace }} | grep cert-manager
      register: cert_manager_check
      failed_when: false
      changed_when: false
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
    
    - name: Add Jetstack Helm repository for Cert-Manager
      command: helm repo add jetstack https://charts.jetstack.io
      when: cert_manager_check.rc != 0
      register: jetstack_repo
      changed_when: "'has been added' in jetstack_repo.stdout"
      failed_when: false
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
    
    - name: Update Helm repositories
      command: helm repo update
      when: cert_manager_check.rc != 0
      changed_when: true
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
    
    - name: Deploy Cert-Manager with Helm
      command: >
        helm install cert-manager jetstack/cert-manager
        --namespace {{ platform_namespace }}
        --create-namespace
        --version {{ cert_manager_chart_version }}
        --set installCRDs=true
        --wait
        --timeout 10m
      when: cert_manager_check.rc != 0
      register: cert_manager_deploy
      changed_when: cert_manager_deploy.rc == 0
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
    
    - name: Wait for Cert-Manager pods to be ready
      command: >
        k3s kubectl wait --for=condition=ready pod
        -l app.kubernetes.io/instance=cert-manager
        -n {{ platform_namespace }}
        --timeout=300s
      when: cert_manager_check.rc != 0
      register: cert_manager_wait
      changed_when: false

    # ============================================================
    # éƒ¨ç½² Harbor (é•œåƒä»“åº“)
    # ============================================================
    - name: Check if Harbor is already installed
      shell: helm list -n {{ platform_namespace }} | grep harbor
      register: harbor_check
      failed_when: false
      changed_when: false
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
    
    - name: Deploy Harbor with Helm (using default values)
      command: >
        helm install harbor harbor/harbor
        --namespace {{ platform_namespace }}
        --create-namespace
        --version {{ harbor_chart_version }}
        --set expose.type=nodePort
        --set expose.tls.enabled=false
        --set expose.nodePort.ports.http.nodePort={{ harbor_http_nodeport }}
        --set persistence.enabled=true
        --set persistence.persistentVolumeClaim.registry.size=10Gi
        --set persistence.persistentVolumeClaim.database.size=2Gi
        --set persistence.persistentVolumeClaim.redis.size=1Gi
        --set persistence.persistentVolumeClaim.trivy.size=5Gi
        --set harborAdminPassword=Harbor12345
        --set trivy.enabled=true
        --wait
        --timeout 15m
      when: harbor_check.rc != 0
      register: harbor_deploy
      changed_when: harbor_deploy.rc == 0
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
    
    - name: Wait for Harbor core pod to be ready
      command: >
        k3s kubectl wait --for=condition=ready pod
        -l component=core
        -n {{ platform_namespace }}
        --timeout=600s
      when: harbor_check.rc != 0
      register: harbor_wait
      changed_when: false
    
    - name: Get Harbor service info
      command: k3s kubectl get svc harbor -n {{ platform_namespace }}
      register: harbor_svc
      changed_when: false
      when: harbor_check.rc != 0
    
    - name: Display Harbor access information
      debug:
        msg: |
          âœ… Harbor deployed successfully!
          
          Access Harbor at: http://<any-node-ip>:{{ harbor_http_nodeport }}
          Default credentials:
            Username: admin
            Password: Harbor12345
          
          Service info:
          {{ harbor_svc.stdout }}
      when: harbor_check.rc != 0

    # ============================================================
    # éƒ¨ç½² ArgoCD (GitOps å¼•æ“)
    # ============================================================
    - name: Check if ArgoCD namespace exists
      command: k3s kubectl get namespace {{ argocd_namespace }}
      register: argocd_ns_check
      failed_when: false
      changed_when: false
    
    - name: Check if ArgoCD is already installed (any method)
      command: k3s kubectl get deployment argocd-server -n {{ argocd_namespace }}
      register: argocd_check
      failed_when: false
      changed_when: false
      when: argocd_ns_check.rc == 0
    
    # === æ–¹æ³• 1: ä½¿ç”¨å®˜æ–¹ Manifest å®‰è£…ï¼ˆæ¨èï¼‰===
    - name: Create ArgoCD namespace
      command: k3s kubectl create namespace {{ argocd_namespace }}
      when: 
        - argocd_install_method == "manifest"
        - argocd_ns_check.rc != 0
      changed_when: true
    
    - name: Deploy ArgoCD using official manifest
      command: >
        k3s kubectl apply -n {{ argocd_namespace }}
        -f {{ argocd_manifest_url }}
      when:
        - argocd_install_method == "manifest"
        - argocd_check.rc != 0 or argocd_ns_check.rc != 0
      register: argocd_manifest_deploy
      changed_when: "'created' in argocd_manifest_deploy.stdout or 'configured' in argocd_manifest_deploy.stdout"
    
    - name: Wait for ArgoCD server deployment to be available
      command: >
        k3s kubectl wait --for=condition=available deployment/argocd-server
        -n {{ argocd_namespace }}
        --timeout=300s
      when:
        - argocd_install_method == "manifest"
        - argocd_check.rc != 0 or argocd_ns_check.rc != 0
      register: argocd_wait_manifest
      changed_when: false
    
    - name: Patch ArgoCD server service to NodePort
      command: >
        k3s kubectl patch svc argocd-server -n {{ argocd_namespace }} -p
        '{"spec":{"type":"NodePort","ports":[{"port":80,"nodePort":{{ argocd_http_nodeport }},"name":"http"},{"port":443,"nodePort":{{ argocd_https_nodeport }},"name":"https"}]}}'
      when:
        - argocd_install_method == "manifest"
        - argocd_check.rc != 0 or argocd_ns_check.rc != 0
      register: argocd_patch_svc
      changed_when: "'patched' in argocd_patch_svc.stdout"
    
    # === æ–¹æ³• 2: ä½¿ç”¨ Helm å®‰è£…ï¼ˆå¤‡é€‰ï¼‰===
    - name: Deploy ArgoCD with Helm
      command: >
        helm install argocd argo/argo-cd
        --namespace {{ argocd_namespace }}
        --create-namespace
        --version {{ argocd_chart_version }}
        --set server.service.type=NodePort
        --set server.service.nodePortHttp={{ argocd_http_nodeport }}
        --set server.service.nodePortHttps={{ argocd_https_nodeport }}
        --set server.extraArgs[0]="--insecure"
        --set configs.params."server\.insecure"=true
        --wait
        --timeout 10m
      when:
        - argocd_install_method == "helm"
        - argocd_check.rc != 0
      register: argocd_helm_deploy
      changed_when: argocd_helm_deploy.rc == 0
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
    
    - name: Wait for ArgoCD server pod to be ready (Helm)
      command: >
        k3s kubectl wait --for=condition=ready pod
        -l app.kubernetes.io/name=argocd-server
        -n {{ argocd_namespace }}
        --timeout=300s
      when:
        - argocd_install_method == "helm"
        - argocd_check.rc != 0
      register: argocd_wait_helm
      changed_when: false
    
    # === é€šç”¨: è·å–å¯†ç å’Œæ˜¾ç¤ºä¿¡æ¯ ===
    - name: Wait for ArgoCD initial admin secret to be created
      command: >
        k3s kubectl get secret argocd-initial-admin-secret
        -n {{ argocd_namespace }}
      register: secret_check
      until: secret_check.rc == 0
      retries: 30
      delay: 5
      when: argocd_check.rc != 0 or argocd_ns_check.rc != 0
      changed_when: false
    
    - name: Get ArgoCD initial admin password
      command: >
        k3s kubectl get secret argocd-initial-admin-secret
        -n {{ argocd_namespace }}
        -o jsonpath="{.data.password}"
      register: argocd_password_base64
      when: argocd_check.rc != 0 or argocd_ns_check.rc != 0
      changed_when: false
    
    - name: Decode ArgoCD password
      shell: echo "{{ argocd_password_base64.stdout }}" | base64 -d
      register: argocd_password
      when: argocd_check.rc != 0 or argocd_ns_check.rc != 0
      changed_when: false
    
    - name: Display ArgoCD access information
      debug:
        msg: |
          âœ… ArgoCD deployed successfully using {{ argocd_install_method }} method!
          
          Access ArgoCD at: http://<any-node-ip>:{{ argocd_http_nodeport }}
          Default credentials:
            Username: admin
            Password: {{ argocd_password.stdout }}
          
          Important: Save this password or change it after first login!
          
          Tip: To change installation method, edit argocd_install_method variable
               Options: 'manifest' (recommended) or 'helm'
      when: argocd_check.rc != 0 or argocd_ns_check.rc != 0

    # ============================================================
    # éƒ¨ç½² GitLab Runner (CI/CD æ‰§è¡Œå™¨)
    # ============================================================
    - name: Check if GitLab Runner namespace exists
      command: k3s kubectl get namespace {{ gitlab_runner_namespace }}
      register: gitlab_runner_ns_check
      failed_when: false
      changed_when: false
    
    - name: Check if GitLab Runner is already installed
      shell: helm list -n {{ gitlab_runner_namespace }} | grep gitlab-runner
      register: gitlab_runner_check
      failed_when: false
      changed_when: false
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      when: gitlab_runner_ns_check.rc == 0
    
    - name: Add GitLab Helm repository
      command: helm repo add gitlab https://charts.gitlab.io
      when: gitlab_runner_check.rc != 0 or gitlab_runner_ns_check.rc != 0
      register: gitlab_repo
      changed_when: "'has been added' in gitlab_repo.stdout"
      failed_when: false
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
    
    - name: Update Helm repositories for GitLab Runner
      command: helm repo update
      when: gitlab_runner_check.rc != 0 or gitlab_runner_ns_check.rc != 0
      changed_when: true
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
    
    - name: Create GitLab Runner values file
      copy:
        dest: /tmp/gitlab-runner-values.yaml
        content: |
          gitlabUrl: {{ gitlab_url }}
          runnerRegistrationToken: {{ gitlab_runner_token }}
          
          runners:
            config: |
              [[runners]]
                [runners.kubernetes]
                  namespace = "{{ gitlab_runner_namespace }}"
                  image = "ubuntu:20.04"
                  privileged = true
                  cpu_request = "100m"
                  memory_request = "128Mi"
                  cpu_limit = "1"
                  memory_limit = "512Mi"
                [[runners.kubernetes.volumes.empty_dir]]
                  name = "docker-certs"
                  mount_path = "/certs/client"
                  medium = "Memory"
          
          rbac:
            create: true
          
          resources:
            limits:
              memory: 256Mi
              cpu: 200m
            requests:
              memory: 128Mi
              cpu: 100m
          
          concurrent: 10
          checkInterval: 30
      when: gitlab_runner_check.rc != 0 or gitlab_runner_ns_check.rc != 0
    
    - name: Deploy GitLab Runner with Helm
      command: >
        helm install gitlab-runner gitlab/gitlab-runner
        --namespace {{ gitlab_runner_namespace }}
        --create-namespace
        --version {{ gitlab_runner_chart_version }}
        -f /tmp/gitlab-runner-values.yaml
        --wait
        --timeout 10m
      when: gitlab_runner_check.rc != 0 or gitlab_runner_ns_check.rc != 0
      register: gitlab_runner_deploy
      changed_when: gitlab_runner_deploy.rc == 0
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
    
    - name: Wait for GitLab Runner pod to be ready
      command: >
        k3s kubectl wait --for=condition=ready pod
        -l app=gitlab-runner
        -n {{ gitlab_runner_namespace }}
        --timeout=300s
      when: gitlab_runner_check.rc != 0 or gitlab_runner_ns_check.rc != 0
      register: gitlab_runner_wait
      changed_when: false
    
    - name: Get GitLab Runner pod status
      command: k3s kubectl get pods -n {{ gitlab_runner_namespace }}
      register: gitlab_runner_pods
      changed_when: false
      when: gitlab_runner_check.rc != 0 or gitlab_runner_ns_check.rc != 0
    
    - name: Get GitLab Runner logs (first 50 lines)
      command: >
        k3s kubectl logs -n {{ gitlab_runner_namespace }}
        -l app=gitlab-runner
        --tail=50
      register: gitlab_runner_logs
      changed_when: false
      when: gitlab_runner_check.rc != 0 or gitlab_runner_ns_check.rc != 0
    
    - name: Display GitLab Runner deployment information
      debug:
        msg: |
          âœ… GitLab Runner deployed successfully!
          
          ğŸ“‹ GitLab Runner Pods:
          {{ gitlab_runner_pods.stdout }}
          
          ğŸ“Š Configuration:
          - GitLab URL: {{ gitlab_url }}
          - Namespace: {{ gitlab_runner_namespace }}
          - Executor: Kubernetes
          - Concurrent jobs: 10
          - Privileged mode: Enabled (for Docker-in-Docker)
          
          ğŸ“ Recent logs:
          {{ gitlab_runner_logs.stdout_lines[-10:] | join('\n') }}
          
          âš ï¸  Next Steps:
          1. Verify runner appears in GitLab: Settings > CI/CD > Runners
          2. Runner should show as "online" with green indicator
          3. Test with a simple .gitlab-ci.yml pipeline
          
          ğŸ’¡ Troubleshooting:
          - Check logs: kubectl logs -n {{ gitlab_runner_namespace }} -l app=gitlab-runner
          - Check token: Ensure gitlab_runner_token is correct in group_vars/all.yml
          - Network: Ensure runner can reach {{ gitlab_url }}
      when: gitlab_runner_check.rc != 0 or gitlab_runner_ns_check.rc != 0

    # ============================================================
    # æœ€ç»ˆéªŒè¯å’Œæ€»ç»“
    # ============================================================
    - name: Get all pods in platform namespace
      command: k3s kubectl get pods -n {{ platform_namespace }}
      register: all_pods
      changed_when: false
    
    - name: Get all services in platform namespace
      command: k3s kubectl get svc -n {{ platform_namespace }}
      register: all_services
      changed_when: false
    
    - name: Get all pods in ArgoCD namespace
      command: k3s kubectl get pods -n {{ argocd_namespace }}
      register: argocd_pods
      changed_when: false
    
    - name: Get all pods in GitLab Runner namespace
      command: k3s kubectl get pods -n {{ gitlab_runner_namespace }}
      register: gitlab_runner_final_pods
      failed_when: false
      changed_when: false
    
    - name: Get cluster node IPs
      shell: k3s kubectl get nodes -o jsonpath='{.items[*].status.addresses[?(@.type=="InternalIP")].address}'
      register: node_ips
      changed_when: false
    
    - name: Display deployment summary
      debug:
        msg: |
          â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
          â•‘          ğŸ‰ Platform Services Deployment Complete!            â•‘
          â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          
          ğŸ“¦ Deployed Services:
          â”œâ”€ Cert-Manager: Certificate management ({{ platform_namespace }} namespace)
          â”œâ”€ Harbor: Container registry ({{ platform_namespace }} namespace)
          â”œâ”€ ArgoCD: GitOps continuous delivery ({{ argocd_namespace }} namespace, {{ argocd_install_method }} method)
          â””â”€ GitLab Runner: CI/CD executor ({{ gitlab_runner_namespace }} namespace)
          
          ğŸŒ Access URLs (use any node IP: {{ node_ips.stdout }}):
          â”œâ”€ Harbor:     http://<node-ip>:{{ harbor_http_nodeport }}
          â”‚              admin / Harbor12345
          â””â”€ ArgoCD:     http://<node-ip>:{{ argocd_http_nodeport }}
                         admin / {{ argocd_password.stdout | default('check secret') }}
          
          ğŸ“‹ Platform Pods ({{ platform_namespace }} namespace):
          {{ all_pods.stdout }}
          
          ğŸ“‹ ArgoCD Pods ({{ argocd_namespace }} namespace):
          {{ argocd_pods.stdout }}
          
          ğŸ“‹ GitLab Runner Pods ({{ gitlab_runner_namespace }} namespace):
          {{ gitlab_runner_final_pods.stdout | default('Not deployed or check failed') }}
          
          ğŸ”— Platform Services:
          {{ all_services.stdout }}
          
          âœ… Next Steps:
          1. Verify GitLab Runner is online in GitLab UI (Settings > CI/CD > Runners)
          2. Access Harbor and create a project for your images
          3. Configure Docker to use Harbor as registry
          4. Create a test .gitlab-ci.yml and trigger a pipeline
          5. Deploy your first application using ArgoCD
          
          ğŸ’¡ Installation Method: {{ argocd_install_method }}
             To change: Edit 'argocd_install_method' in playbook vars
          ğŸ“– Documentation: docs/operations/installation.md
          ğŸ“– Troubleshooting: TROUBLESHOOTING.md
    
    - name: Create quick access script
      copy:
        dest: /tmp/platform-access.sh
        mode: '0755'
        content: |
          #!/bin/bash
          # Quick access script for platform services
          
          NODE_IP=$(hostname -I | awk '{print $1}')
          
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘              Platform Services Access Information              â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "ğŸŒ Harbor:     http://${NODE_IP}:{{ harbor_http_nodeport }}"
          echo "   Username:   admin"
          echo "   Password:   Harbor12345"
          echo ""
          echo "ğŸŒ ArgoCD:     http://${NODE_IP}:{{ argocd_http_nodeport }}"
          echo "   Username:   admin"
          echo "   Password:   $(kubectl get secret argocd-initial-admin-secret -n {{ argocd_namespace }} -o jsonpath="{.data.password}" | base64 -d 2>/dev/null || echo 'Run: kubectl get secret argocd-initial-admin-secret -n {{ argocd_namespace }} -o jsonpath={.data.password} | base64 -d')"
          echo ""
          echo "ğŸ“Š Check pod status:"
          echo "   kubectl get pods -n {{ platform_namespace }}"
          echo "   kubectl get pods -n {{ argocd_namespace }}"
          echo ""
      
    - name: Display access script location
      debug:
        msg: |
          ğŸ’¡ Tip: A quick access script has been created at /tmp/platform-access.sh
          Run it anytime with: /tmp/platform-access.sh
